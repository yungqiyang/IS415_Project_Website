<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.4.549">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Russell Tio Junhao, Yung Qi Yang, Ham Yan Choon Glenn">

<title>IS415 Project Website - User Guide</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../site_libs/clipboard/clipboard.min.js"></script>
<script src="../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../site_libs/quarto-search/fuse.min.js"></script>
<script src="../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../">
<script src="../site_libs/quarto-html/quarto.js"></script>
<script src="../site_libs/quarto-html/popper.min.js"></script>
<script src="../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../site_libs/quarto-html/anchor.min.js"></script>
<link href="../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>


<link rel="stylesheet" href="../styles.css">
</head>

<body class="nav-fixed">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="../index.html">
    <span class="navbar-title">IS415 Project Website</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link" href="../Project_Proposal/Project_Proposal.html"> 
<span class="menu-text">Project Proposal</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link active" href="../User_Guide/User_Guide.html" aria-current="page"> 
<span class="menu-text">User Guide</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="https://yung-qi-yang.shinyapps.io/IS415_Project_App/"> 
<span class="menu-text">Application</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="https://github.com/FieryCake/IS415"> 
<span class="menu-text">Project Repository</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../index.html"> 
<span class="menu-text">Home</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../about.html"> 
<span class="menu-text">About</span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
          <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#user-guide" id="toc-user-guide" class="nav-link active" data-scroll-target="#user-guide">User guide</a></li>
  <li><a href="#navigation" id="toc-navigation" class="nav-link" data-scroll-target="#navigation">Navigation</a></li>
  <li><a href="#geographic-accessibility" id="toc-geographic-accessibility" class="nav-link" data-scroll-target="#geographic-accessibility">Geographic Accessibility&nbsp;</a></li>
  <li><a href="#hotspot-analysis---heatmaps" id="toc-hotspot-analysis---heatmaps" class="nav-link" data-scroll-target="#hotspot-analysis---heatmaps">Hotspot Analysis - HeatMaps</a></li>
  <li><a href="#hotspot-analysis---clustering" id="toc-hotspot-analysis---clustering" class="nav-link" data-scroll-target="#hotspot-analysis---clustering">Hotspot Analysis - Clustering</a></li>
  <li><a href="#hotspot-analysis---hotspots" id="toc-hotspot-analysis---hotspots" class="nav-link" data-scroll-target="#hotspot-analysis---hotspots">Hotspot Analysis - Hotspots</a></li>
  <li><a href="#geospatial-segmentation---data-scope-options" id="toc-geospatial-segmentation---data-scope-options" class="nav-link" data-scroll-target="#geospatial-segmentation---data-scope-options">Geospatial Segmentation - Data Scope Options</a></li>
  <li><a href="#geospatial-segmentation---scaling-distribution" id="toc-geospatial-segmentation---scaling-distribution" class="nav-link" data-scroll-target="#geospatial-segmentation---scaling-distribution">Geospatial Segmentation - Scaling Distribution</a></li>
  <li><a href="#geospatial-segmentation---hyperparameter-tuning" id="toc-geospatial-segmentation---hyperparameter-tuning" class="nav-link" data-scroll-target="#geospatial-segmentation---hyperparameter-tuning">Geospatial Segmentation - Hyperparameter Tuning</a></li>
  <li><a href="#geospatial-segmentation---cluster-visualisation" id="toc-geospatial-segmentation---cluster-visualisation" class="nav-link" data-scroll-target="#geospatial-segmentation---cluster-visualisation">Geospatial Segmentation - Cluster Visualisation</a></li>
  <li><a href="#geospatial-segmentation---cluster-distribution" id="toc-geospatial-segmentation---cluster-distribution" class="nav-link" data-scroll-target="#geospatial-segmentation---cluster-distribution">Geospatial Segmentation - Cluster Distribution</a></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">User Guide</h1>
</div>



<div class="quarto-title-meta">

    <div>
    <div class="quarto-title-meta-heading">Author</div>
    <div class="quarto-title-meta-contents">
             <p>Russell Tio Junhao, Yung Qi Yang, Ham Yan Choon Glenn </p>
          </div>
  </div>
    
  
    
  </div>
  


</header>


<section id="user-guide" class="level1">
<h1>User guide</h1>
<p>User guide for group 12’s amenities data analysis tool.</p>
</section>
<section id="navigation" class="level1">
<h1>Navigation</h1>
<p><img src="images/clipboard-1265827130.png" class="img-fluid"></p>
<p>Our main navigation bar consists of our title - “<strong>Accessibility of Amenities in Singapore</strong>”, and our modules -”<strong>Project introduction</strong>, <strong>Poster, Geographic Accessibility</strong>, <strong>Hotspot Analysis</strong> and <strong>Geospatial Segmentation</strong>”. When a user first enters the webpage, they would be brought to the tab “Project Introduction” by default.&nbsp;</p>
</section>
<section id="geographic-accessibility" class="level1">
<h1>Geographic Accessibility&nbsp;</h1>
<p><img src="images/clipboard-901742359.png" class="img-fluid"></p>
<p>In this page, you can view the Accessibility map of each amenity type. You can filter the map by amenity type, accessibility computation method and map palette style. When hovering over the map, you can see the details of that specific amenity location, or the accessibility value of the hexagon. Try changing the palette style around to Best match your visual preference.</p>
</section>
<section id="hotspot-analysis---heatmaps" class="level1">
<h1>Hotspot Analysis - HeatMaps</h1>
<p><img src="images/clipboard-2234043038.png" class="img-fluid"></p>
<p>In the <strong>HeatMaps</strong> tab, users would be presented a map of Singapore which gives them a brief overview of the amenities frequency in Singapore. This map will indicate areas with different concentrations of amenities and the concentration will be represented by the color tones. With a brief glance, users can see higher concentration areas of the different amenities and users have the ability to filter between the number of clusters they want, mapping styles, the different amenities and also other map design options.&nbsp;</p>
</section>
<section id="hotspot-analysis---clustering" class="level1">
<h1>Hotspot Analysis - Clustering</h1>
<p><img src="images/clipboard-3094844586.png" class="img-fluid"></p>
<p>Next, the Local moran plots under clustering, presents users a view of spatial autocorrelation in Singapore between the different amenities. This map will identify clusters by treating individual subzones as an independent entity to compare with its neighbors. If the entity itself and its neighbors have values that indicate high moran values, that indicates a cluster which is highlighted in green on the map. This is further supported by the p values on the right map, indicating the significance of clusters. The different filters that a user can use are filter by amenities, number of classes for local moran, and also map design options.&nbsp;</p>
</section>
<section id="hotspot-analysis---hotspots" class="level1">
<h1>Hotspot Analysis - Hotspots</h1>
<p><img src="images/clipboard-2444266903.png" class="img-fluid"></p>
<p>Lastly, we have the hotspot analysis tab where the user is presented with an interactive map of Singapore where they can mouse over to see the regions which are considered hotspots, coldspots and not significant. Unlike local moran, hotspot analysis analyzes the regions as a whole rather than comparing entities independently to derive hotspots and coldspots. Users can filter by zones and the different amenities for their visualization.&nbsp;</p>
</section>
<section id="geospatial-segmentation---data-scope-options" class="level1">
<h1>Geospatial Segmentation - Data Scope Options</h1>
<p><img src="images/clipboard-1403519661.png" class="img-fluid" width="251"></p>
<p>In this sidebar panel, you will find 3 options. These 3 options will determine the type of data upon which the entire module will run upon. ‘Planning Level’ allows analysis to run on the 3 different master plan levels available, whilst ‘Planning Zone’ will allow for greater flexibility by allowing the user to select exactly which spatial polygons at the selected planning level to analyse. Finally, ‘Select Amenities’ will let the user decide which amenities (minimum 1) upon which the clustering analysis will be computed across. By default, ‘Planning Area’ and all its respective spatial polygons are selected, and the analysis will be done across all amenities simultaneously.</p>
</section>
<section id="geospatial-segmentation---scaling-distribution" class="level1">
<h1>Geospatial Segmentation - Scaling Distribution</h1>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="images/clipboard-514428886.png" class="img-fluid figure-img"></p>
<figcaption>In this Tab, you will find the distribution graphs of a single chosen amenity (using the ‘Amenity to Visualise’ Option in the ‘Scaling Options’ side panel), amongst the prior selected list of amenities, when different scaling methods are applied to the data. The 3 available graphs are the non-standardised, Min-Max standardised and Z-score standardised counts of the amenities. A continuous, density graph option is also available. This visualisation allows the user to decide upon the most suitable standardisation method to use by means of the ‘Scaling Method’ option.</figcaption>
</figure>
</div>
</section>
<section id="geospatial-segmentation---hyperparameter-tuning" class="level1">
<h1>Geospatial Segmentation - Hyperparameter Tuning</h1>
<p><img src="images/clipboard-3461081397.png" class="img-fluid"></p>
<p>This tab allows the user to investigate and decide upon the number of clustering groups to use in the clustering algorithm. The options available to the user here are primarily found in the ‘Hyperparameter Tuning’ sidebar panel. Here the available sliders and options relate directly to the options found in the <strong>fviz_nbclust()</strong> function from the factoextra R-package. The optimum clustering distribution graph is impacted not only by these functions, but also by the ‘Clustering Algorithm’ selected under the ‘Cluster Options’ sidebar panel as well as the respective, relevant options available to the selected algorithm.</p>
<p><img src="https://lh7-us.googleusercontent.com/6uMN4XhJ4DKPCJosT8ivYXWqTbvkMZo8_9IN5gUb9SjoqpG8JMghP76D5vJZAwXDKYYOaobR7slyS5Q9sx1mwi2u0uK-Iv786GfaleRdrBuUl6c8ljbHM6KK-fSUYU6g9zODmUKEtkuQY95cmHoCe9g.png" class="img-fluid" width="240"></p>
<p>For instance, the selection of the k-means algorithm will parse the kmeans() function into the <strong>fviz_nbclust()</strong> function at the backend, thus affecting the optimum cluster distribution graph. Finally, ‘Number of Clusters’ will determine the user-defined number of clusters to the clustering algorithm in our final analysis. If a spatially-constrained Ward hierarchical algorithm is chosen as the clustering method, an additional slider option and graph for the algorithm’s alpha value will be needed/produced.</p>
<p><img src="images/clipboard-4004446248.png" class="img-fluid"></p>
</section>
<section id="geospatial-segmentation---cluster-visualisation" class="level1">
<h1>Geospatial Segmentation - Cluster Visualisation</h1>
<p>In this panel, the user can examine and investigate the clustering results of their selected clustering algorithm and clustering parameters on an interactive view map, with OpenStreetMap as its base. Clicking upon each cluster polygon will provide the user with detailed information about the chosen planning area (or whichever planning level chosen) along with the number of each amenity found in the selected area. Further options are provided to the user to beautify the map according to their own tastes through the first 4 options found in the ‘Stylistic Options’ sidebar. ‘Map Colour Style’ uses RColorBrewer palettes to provide an incredibly diverse set of creative options.</p>
<p><img src="images/clipboard-4011095794.png" class="img-fluid"></p>
</section>
<section id="geospatial-segmentation---cluster-distribution" class="level1">
<h1>Geospatial Segmentation - Cluster Distribution</h1>
<p><img src="images/clipboard-3642803996.png" class="img-fluid"></p>
<p>In this final panel, the user is presented with the multivariate parallel distribution plots of amenities within and across each cluster. Again, creative options are presented to the user in the ‘Stylistic Options’ sidebar tab, under the stylistic map options presented earlier. If the clustering analysis was conducted on a univariate, the distribution plot here will instead be a boxplot with a different set of beauty options available for the user in the same panel.</p>


</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>